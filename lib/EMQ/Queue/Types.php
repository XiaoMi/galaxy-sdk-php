<?php
namespace EMQ\Queue;

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


final class Permission {
  const NONE = 0;
  const SEND_MESSAGE = 1;
  const RECEIVE_MESSAGE = 2;
  const SEND_RECEIVE_MESSAGE = 3;
  const HANDLE_MESSAGE = 4;
  const SEND_HANDLE_MESSAGE = 5;
  const GET_QUEUE_INFO = 6;
  const USE_QUEUE = 7;
  const ADMIN_QUEUE = 8;
  const FULL_CONTROL = 9;
  static public $__names = array(
    0 => 'NONE',
    1 => 'SEND_MESSAGE',
    2 => 'RECEIVE_MESSAGE',
    3 => 'SEND_RECEIVE_MESSAGE',
    4 => 'HANDLE_MESSAGE',
    5 => 'SEND_HANDLE_MESSAGE',
    6 => 'GET_QUEUE_INFO',
    7 => 'USE_QUEUE',
    8 => 'ADMIN_QUEUE',
    9 => 'FULL_CONTROL',
  );
}

/**
 * Copyright 2015, Xiaomi.
 * All rights reserved.
 * Author: shenyuannan@xiaomi.com
 */
class QueueAttribute {
  static $_TSPEC;

  /**
   * Queue delay seconds, message send to this queue will invisible until after
   * delaySeconds, default 0s (0s ~ 15min)
   * 
   * 
   * @var int
   */
  public $delaySeconds = null;
  /**
   * Queue invisibility seconds, after message received form this queue, in
   * invisibilitySeconds this will not received through receiveMessage. When
   * after invisibilitySeconds if no deleteMessage called for this message, this
   * message will receive again, default 30s (2s ~ 12hour)
   * 
   * 
   * @var int
   */
  public $invisibilitySeconds = null;
  /**
   * The seconds wait when receiveMessage called, default 0s (0s ~ 20s)
   * 
   * 
   * @var int
   */
  public $receiveMessageWaitSeconds = null;
  /**
   * Maximum receive message number in this queue, default 100(1 ~ 100)
   * 
   * 
   * @var int
   */
  public $receiveMessageMaximumNumber = null;
  /**
   * message retention seconds in this queue, default 4days (60s ~ 14days)
   * 
   * 
   * @var int
   */
  public $messageRetentionSeconds = null;
  /**
   * Max message size in this queue, default 256K (1K ~ 256K)
   * 
   * 
   * @var int
   */
  public $messageMaximumBytes = null;
  /**
   * Partition number for this queue default 4 (1 ~ 255)
   * 
   * 
   * @var int
   */
  public $partitionNumber = null;
  /**
   * User-defined attributes;
   * 
   * 
   * @var array
   */
  public $userAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'delaySeconds',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'invisibilitySeconds',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'receiveMessageWaitSeconds',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'receiveMessageMaximumNumber',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'messageRetentionSeconds',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'messageMaximumBytes',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'partitionNumber',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'userAttributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['delaySeconds'])) {
        $this->delaySeconds = $vals['delaySeconds'];
      }
      if (isset($vals['invisibilitySeconds'])) {
        $this->invisibilitySeconds = $vals['invisibilitySeconds'];
      }
      if (isset($vals['receiveMessageWaitSeconds'])) {
        $this->receiveMessageWaitSeconds = $vals['receiveMessageWaitSeconds'];
      }
      if (isset($vals['receiveMessageMaximumNumber'])) {
        $this->receiveMessageMaximumNumber = $vals['receiveMessageMaximumNumber'];
      }
      if (isset($vals['messageRetentionSeconds'])) {
        $this->messageRetentionSeconds = $vals['messageRetentionSeconds'];
      }
      if (isset($vals['messageMaximumBytes'])) {
        $this->messageMaximumBytes = $vals['messageMaximumBytes'];
      }
      if (isset($vals['partitionNumber'])) {
        $this->partitionNumber = $vals['partitionNumber'];
      }
      if (isset($vals['userAttributes'])) {
        $this->userAttributes = $vals['userAttributes'];
      }
    }
  }

  public function getName() {
    return 'QueueAttribute';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->delaySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->invisibilitySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->receiveMessageWaitSeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->receiveMessageMaximumNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->messageRetentionSeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->messageMaximumBytes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->partitionNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::MAP) {
            $this->userAttributes = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = '';
              $val6 = '';
              $xfer += $input->readString($key5);
              $xfer += $input->readString($val6);
              $this->userAttributes[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueueAttribute');
    if ($this->delaySeconds !== null) {
      $xfer += $output->writeFieldBegin('delaySeconds', TType::I32, 1);
      $xfer += $output->writeI32($this->delaySeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->invisibilitySeconds !== null) {
      $xfer += $output->writeFieldBegin('invisibilitySeconds', TType::I32, 2);
      $xfer += $output->writeI32($this->invisibilitySeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiveMessageWaitSeconds !== null) {
      $xfer += $output->writeFieldBegin('receiveMessageWaitSeconds', TType::I32, 3);
      $xfer += $output->writeI32($this->receiveMessageWaitSeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiveMessageMaximumNumber !== null) {
      $xfer += $output->writeFieldBegin('receiveMessageMaximumNumber', TType::I32, 4);
      $xfer += $output->writeI32($this->receiveMessageMaximumNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageRetentionSeconds !== null) {
      $xfer += $output->writeFieldBegin('messageRetentionSeconds', TType::I32, 5);
      $xfer += $output->writeI32($this->messageRetentionSeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageMaximumBytes !== null) {
      $xfer += $output->writeFieldBegin('messageMaximumBytes', TType::I32, 6);
      $xfer += $output->writeI32($this->messageMaximumBytes);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionNumber !== null) {
      $xfer += $output->writeFieldBegin('partitionNumber', TType::I32, 7);
      $xfer += $output->writeI32($this->partitionNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userAttributes !== null) {
      if (!is_array($this->userAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userAttributes', TType::MAP, 8);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->userAttributes));
        {
          foreach ($this->userAttributes as $kiter7 => $viter8)
          {
            $xfer += $output->writeString($kiter7);
            $xfer += $output->writeString($viter8);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueueState {
  static $_TSPEC;

  /**
   * Queue create timestamp;
   * 
   * 
   * @var int
   */
  public $createTimestamp = null;
  /**
   * Queue last modified timestamp;
   * 
   * 
   * @var int
   */
  public $lastModifiedTimestamp = null;
  /**
   * The approximate message number in this queue;
   * 
   * 
   * @var int
   */
  public $approximateMessageNumber = null;
  /**
   * The available message number in this queue, this is for message that could
   * be get using receivedMessage
   * 
   * 
   * @var int
   */
  public $approximateAvailableMessageNumber = null;
  /**
   * The invisibility message number in this queue, this is for received message
   * that in invisibilitySeconds and not deleted;
   * 
   * 
   * @var int
   */
  public $approximateInvisibilityMessageNumber = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'createTimestamp',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'lastModifiedTimestamp',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'approximateMessageNumber',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'approximateAvailableMessageNumber',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'approximateInvisibilityMessageNumber',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['createTimestamp'])) {
        $this->createTimestamp = $vals['createTimestamp'];
      }
      if (isset($vals['lastModifiedTimestamp'])) {
        $this->lastModifiedTimestamp = $vals['lastModifiedTimestamp'];
      }
      if (isset($vals['approximateMessageNumber'])) {
        $this->approximateMessageNumber = $vals['approximateMessageNumber'];
      }
      if (isset($vals['approximateAvailableMessageNumber'])) {
        $this->approximateAvailableMessageNumber = $vals['approximateAvailableMessageNumber'];
      }
      if (isset($vals['approximateInvisibilityMessageNumber'])) {
        $this->approximateInvisibilityMessageNumber = $vals['approximateInvisibilityMessageNumber'];
      }
    }
  }

  public function getName() {
    return 'QueueState';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->createTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lastModifiedTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approximateMessageNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approximateAvailableMessageNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approximateInvisibilityMessageNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueueState');
    if ($this->createTimestamp !== null) {
      $xfer += $output->writeFieldBegin('createTimestamp', TType::I64, 1);
      $xfer += $output->writeI64($this->createTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastModifiedTimestamp !== null) {
      $xfer += $output->writeFieldBegin('lastModifiedTimestamp', TType::I64, 2);
      $xfer += $output->writeI64($this->lastModifiedTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approximateMessageNumber !== null) {
      $xfer += $output->writeFieldBegin('approximateMessageNumber', TType::I64, 3);
      $xfer += $output->writeI64($this->approximateMessageNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approximateAvailableMessageNumber !== null) {
      $xfer += $output->writeFieldBegin('approximateAvailableMessageNumber', TType::I64, 4);
      $xfer += $output->writeI64($this->approximateAvailableMessageNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approximateInvisibilityMessageNumber !== null) {
      $xfer += $output->writeFieldBegin('approximateInvisibilityMessageNumber', TType::I64, 5);
      $xfer += $output->writeI64($this->approximateInvisibilityMessageNumber);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Throughput {
  static $_TSPEC;

  /**
   * Queue read qps;
   * 
   * 
   * @var int
   */
  public $readQps = null;
  /**
   * Queue write qps;
   * 
   * 
   * @var int
   */
  public $writeQps = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'readQps',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'writeQps',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['readQps'])) {
        $this->readQps = $vals['readQps'];
      }
      if (isset($vals['writeQps'])) {
        $this->writeQps = $vals['writeQps'];
      }
    }
  }

  public function getName() {
    return 'Throughput';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->readQps);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->writeQps);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Throughput');
    if ($this->readQps !== null) {
      $xfer += $output->writeFieldBegin('readQps', TType::I64, 1);
      $xfer += $output->writeI64($this->readQps);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->writeQps !== null) {
      $xfer += $output->writeFieldBegin('writeQps', TType::I64, 2);
      $xfer += $output->writeI64($this->writeQps);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueueQuota {
  static $_TSPEC;

  /**
   * Queue read and qps;
   * 
   * 
   * @var \EMQ\Queue\Throughput
   */
  public $throughput = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        2 => array(
          'var' => 'throughput',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\Throughput',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['throughput'])) {
        $this->throughput = $vals['throughput'];
      }
    }
  }

  public function getName() {
    return 'QueueQuota';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->throughput = new \EMQ\Queue\Throughput();
            $xfer += $this->throughput->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueueQuota');
    if ($this->throughput !== null) {
      if (!is_object($this->throughput)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('throughput', TType::STRUCT, 2);
      $xfer += $this->throughput->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateQueueRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;
  /**
   * The queue quota, including space quota, read qps, and write qps;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;
  /**
   * Set the queue be a dead letter queue or not;
   * 
   * 
   * @var bool
   */
  public $deadLetterQueue = null;
  /**
   * Set the queue be a topic queue or not;
   * All messages with the same topic in topic queue will be received one by one
   * Default: false
   * 
   * 
   * @var bool
   */
  public $topicQueue = null;
  /**
   * Purge expired messages even if they have not been received by users
   * Default: true
   * 
   * 
   * @var bool
   */
  public $deleteMessageForce = true;
  /**
   * Name default tag
   * You can use "" as default tag name while receiving messages if this field is not set
   * 
   * 
   * @var string
   */
  public $defaultTagName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        3 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        4 => array(
          'var' => 'deadLetterQueue',
          'type' => TType::BOOL,
          ),
        6 => array(
          'var' => 'topicQueue',
          'type' => TType::BOOL,
          ),
        7 => array(
          'var' => 'deleteMessageForce',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'defaultTagName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
      if (isset($vals['deadLetterQueue'])) {
        $this->deadLetterQueue = $vals['deadLetterQueue'];
      }
      if (isset($vals['topicQueue'])) {
        $this->topicQueue = $vals['topicQueue'];
      }
      if (isset($vals['deleteMessageForce'])) {
        $this->deleteMessageForce = $vals['deleteMessageForce'];
      }
      if (isset($vals['defaultTagName'])) {
        $this->defaultTagName = $vals['defaultTagName'];
      }
    }
  }

  public function getName() {
    return 'CreateQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deadLetterQueue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->topicQueue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteMessageForce);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->defaultTagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateQueueRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 3);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deadLetterQueue !== null) {
      $xfer += $output->writeFieldBegin('deadLetterQueue', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deadLetterQueue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topicQueue !== null) {
      $xfer += $output->writeFieldBegin('topicQueue', TType::BOOL, 6);
      $xfer += $output->writeBool($this->topicQueue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteMessageForce !== null) {
      $xfer += $output->writeFieldBegin('deleteMessageForce', TType::BOOL, 7);
      $xfer += $output->writeBool($this->deleteMessageForce);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultTagName !== null) {
      $xfer += $output->writeFieldBegin('defaultTagName', TType::STRING, 8);
      $xfer += $output->writeString($this->defaultTagName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateQueueResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * The name returned here may be a little different from user set in request (with developerId as prefix).
   * So the user should use the name returned by this response for those following operations
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;
  /**
   * The queue is a dead letter queue or not;
   * 
   * 
   * @var bool
   */
  public $deadLetterQueue = null;
  /**
   * Set the queue be a topic queue or not;
   * 
   * 
   * @var bool
   */
  public $topicQueue = null;
  /**
   * Purge expired messages even if they have not been received by users
   * 
   * 
   * @var bool
   */
  public $deleteMessageForce = null;
  /**
   * @var string
   */
  public $defaultTagName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        3 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        4 => array(
          'var' => 'deadLetterQueue',
          'type' => TType::BOOL,
          ),
        6 => array(
          'var' => 'topicQueue',
          'type' => TType::BOOL,
          ),
        7 => array(
          'var' => 'deleteMessageForce',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'defaultTagName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
      if (isset($vals['deadLetterQueue'])) {
        $this->deadLetterQueue = $vals['deadLetterQueue'];
      }
      if (isset($vals['topicQueue'])) {
        $this->topicQueue = $vals['topicQueue'];
      }
      if (isset($vals['deleteMessageForce'])) {
        $this->deleteMessageForce = $vals['deleteMessageForce'];
      }
      if (isset($vals['defaultTagName'])) {
        $this->defaultTagName = $vals['defaultTagName'];
      }
    }
  }

  public function getName() {
    return 'CreateQueueResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deadLetterQueue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->topicQueue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteMessageForce);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->defaultTagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateQueueResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 3);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deadLetterQueue !== null) {
      $xfer += $output->writeFieldBegin('deadLetterQueue', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deadLetterQueue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topicQueue !== null) {
      $xfer += $output->writeFieldBegin('topicQueue', TType::BOOL, 6);
      $xfer += $output->writeBool($this->topicQueue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteMessageForce !== null) {
      $xfer += $output->writeFieldBegin('deleteMessageForce', TType::BOOL, 7);
      $xfer += $output->writeBool($this->deleteMessageForce);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultTagName !== null) {
      $xfer += $output->writeFieldBegin('defaultTagName', TType::STRING, 8);
      $xfer += $output->writeString($this->defaultTagName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DeleteQueueRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'DeleteQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeleteQueueRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PurgeQueueRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'PurgeQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PurgeQueueRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueAttributesRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
    }
  }

  public function getName() {
    return 'SetQueueAttributesRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueAttributesRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueAttributesResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
    }
  }

  public function getName() {
    return 'SetQueueAttributesResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueAttributesResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueQuotaRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'SetQueueQuotaRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueQuotaRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 2);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueQuotaResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
    }
  }

  public function getName() {
    return 'SetQueueQuotaResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueQuotaResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 2);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class RedrivePolicy {
  static $_TSPEC;

  /**
   * The dead letter queue name;
   * 
   * 
   * @var string
   */
  public $dlqName = null;
  /**
   * The max receive time;
   * 
   * 
   * @var int
   */
  public $maxReceiveTime = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dlqName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'maxReceiveTime',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dlqName'])) {
        $this->dlqName = $vals['dlqName'];
      }
      if (isset($vals['maxReceiveTime'])) {
        $this->maxReceiveTime = $vals['maxReceiveTime'];
      }
    }
  }

  public function getName() {
    return 'RedrivePolicy';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dlqName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->maxReceiveTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RedrivePolicy');
    if ($this->dlqName !== null) {
      $xfer += $output->writeFieldBegin('dlqName', TType::STRING, 1);
      $xfer += $output->writeString($this->dlqName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxReceiveTime !== null) {
      $xfer += $output->writeFieldBegin('maxReceiveTime', TType::I32, 2);
      $xfer += $output->writeI32($this->maxReceiveTime);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetQueueInfoRequest {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'GetQueueInfoRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetQueueInfoRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetQueueInfoResponse {
  static $_TSPEC;

  /**
   * The queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * The queue attribute;
   * 
   * 
   * @var \EMQ\Queue\QueueAttribute
   */
  public $queueAttribute = null;
  /**
   * The queue state;
   * 
   * 
   * @var \EMQ\Queue\QueueState
   */
  public $queueState = null;
  /**
   * The queue quota;
   * 
   * 
   * @var \EMQ\Queue\QueueQuota
   */
  public $queueQuota = null;
  /**
   * Whether the queue is a dead letter queue;
   * 
   * 
   * @var bool
   */
  public $isDeadLetterQueue = null;
  /**
   * The queue redrive policy, dead letter queue doesn't have redrive policy;
   * 
   * 
   * @var \EMQ\Queue\RedrivePolicy
   */
  public $redrivePolicy = null;
  /**
   * Set the queue be a topic queue or not;
   * 
   * 
   * @var bool
   */
  public $topicQueue = null;
  /**
   * Purge expired messages even if they have not been received by users
   * 
   * 
   * @var bool
   */
  public $deleteMessageForce = null;
  /**
   * @var string
   */
  public $defaultTagName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'queueAttribute',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueAttribute',
          ),
        3 => array(
          'var' => 'queueState',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueState',
          ),
        4 => array(
          'var' => 'queueQuota',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueQuota',
          ),
        5 => array(
          'var' => 'isDeadLetterQueue',
          'type' => TType::BOOL,
          ),
        6 => array(
          'var' => 'redrivePolicy',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\RedrivePolicy',
          ),
        8 => array(
          'var' => 'topicQueue',
          'type' => TType::BOOL,
          ),
        9 => array(
          'var' => 'deleteMessageForce',
          'type' => TType::BOOL,
          ),
        10 => array(
          'var' => 'defaultTagName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['queueAttribute'])) {
        $this->queueAttribute = $vals['queueAttribute'];
      }
      if (isset($vals['queueState'])) {
        $this->queueState = $vals['queueState'];
      }
      if (isset($vals['queueQuota'])) {
        $this->queueQuota = $vals['queueQuota'];
      }
      if (isset($vals['isDeadLetterQueue'])) {
        $this->isDeadLetterQueue = $vals['isDeadLetterQueue'];
      }
      if (isset($vals['redrivePolicy'])) {
        $this->redrivePolicy = $vals['redrivePolicy'];
      }
      if (isset($vals['topicQueue'])) {
        $this->topicQueue = $vals['topicQueue'];
      }
      if (isset($vals['deleteMessageForce'])) {
        $this->deleteMessageForce = $vals['deleteMessageForce'];
      }
      if (isset($vals['defaultTagName'])) {
        $this->defaultTagName = $vals['defaultTagName'];
      }
    }
  }

  public function getName() {
    return 'GetQueueInfoResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->queueAttribute = new \EMQ\Queue\QueueAttribute();
            $xfer += $this->queueAttribute->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->queueState = new \EMQ\Queue\QueueState();
            $xfer += $this->queueState->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->queueQuota = new \EMQ\Queue\QueueQuota();
            $xfer += $this->queueQuota->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isDeadLetterQueue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->redrivePolicy = new \EMQ\Queue\RedrivePolicy();
            $xfer += $this->redrivePolicy->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->topicQueue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteMessageForce);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->defaultTagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetQueueInfoResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueAttribute !== null) {
      if (!is_object($this->queueAttribute)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueAttribute', TType::STRUCT, 2);
      $xfer += $this->queueAttribute->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueState !== null) {
      if (!is_object($this->queueState)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueState', TType::STRUCT, 3);
      $xfer += $this->queueState->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queueQuota !== null) {
      if (!is_object($this->queueQuota)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueQuota', TType::STRUCT, 4);
      $xfer += $this->queueQuota->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isDeadLetterQueue !== null) {
      $xfer += $output->writeFieldBegin('isDeadLetterQueue', TType::BOOL, 5);
      $xfer += $output->writeBool($this->isDeadLetterQueue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->redrivePolicy !== null) {
      if (!is_object($this->redrivePolicy)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('redrivePolicy', TType::STRUCT, 6);
      $xfer += $this->redrivePolicy->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topicQueue !== null) {
      $xfer += $output->writeFieldBegin('topicQueue', TType::BOOL, 8);
      $xfer += $output->writeBool($this->topicQueue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteMessageForce !== null) {
      $xfer += $output->writeFieldBegin('deleteMessageForce', TType::BOOL, 9);
      $xfer += $output->writeBool($this->deleteMessageForce);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultTagName !== null) {
      $xfer += $output->writeFieldBegin('defaultTagName', TType::STRING, 10);
      $xfer += $output->writeString($this->defaultTagName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueRedrivePolicyRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var \EMQ\Queue\RedrivePolicy
   */
  public $redrivePolicy = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'redrivePolicy',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\RedrivePolicy',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['redrivePolicy'])) {
        $this->redrivePolicy = $vals['redrivePolicy'];
      }
    }
  }

  public function getName() {
    return 'SetQueueRedrivePolicyRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->redrivePolicy = new \EMQ\Queue\RedrivePolicy();
            $xfer += $this->redrivePolicy->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueRedrivePolicyRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->redrivePolicy !== null) {
      if (!is_object($this->redrivePolicy)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('redrivePolicy', TType::STRUCT, 2);
      $xfer += $this->redrivePolicy->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetQueueRedrivePolicyResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var \EMQ\Queue\RedrivePolicy
   */
  public $redrivePolicy = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'redrivePolicy',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\RedrivePolicy',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['redrivePolicy'])) {
        $this->redrivePolicy = $vals['redrivePolicy'];
      }
    }
  }

  public function getName() {
    return 'SetQueueRedrivePolicyResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->redrivePolicy = new \EMQ\Queue\RedrivePolicy();
            $xfer += $this->redrivePolicy->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetQueueRedrivePolicyResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->redrivePolicy !== null) {
      if (!is_object($this->redrivePolicy)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('redrivePolicy', TType::STRUCT, 2);
      $xfer += $this->redrivePolicy->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class RemoveQueueRedrivePolicyRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'RemoveQueueRedrivePolicyRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RemoveQueueRedrivePolicyRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListDeadLetterSourceQueuesRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $dlqName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dlqName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dlqName'])) {
        $this->dlqName = $vals['dlqName'];
      }
    }
  }

  public function getName() {
    return 'ListDeadLetterSourceQueuesRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dlqName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListDeadLetterSourceQueuesRequest');
    if ($this->dlqName !== null) {
      $xfer += $output->writeFieldBegin('dlqName', TType::STRING, 1);
      $xfer += $output->writeString($this->dlqName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListDeadLetterSourceQueuesResponse {
  static $_TSPEC;

  /**
   * The dead letter queue name;
   * 
   * 
   * @var string
   */
  public $dlqName = null;
  /**
   * The source queues, only a dead letter queue has source queues;
   * 
   * 
   * @var string[]
   */
  public $sourceQueues = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dlqName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'sourceQueues',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dlqName'])) {
        $this->dlqName = $vals['dlqName'];
      }
      if (isset($vals['sourceQueues'])) {
        $this->sourceQueues = $vals['sourceQueues'];
      }
    }
  }

  public function getName() {
    return 'ListDeadLetterSourceQueuesResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dlqName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->sourceQueues = array();
            $_size9 = 0;
            $_etype12 = 0;
            $xfer += $input->readListBegin($_etype12, $_size9);
            for ($_i13 = 0; $_i13 < $_size9; ++$_i13)
            {
              $elem14 = null;
              $xfer += $input->readString($elem14);
              $this->sourceQueues []= $elem14;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListDeadLetterSourceQueuesResponse');
    if ($this->dlqName !== null) {
      $xfer += $output->writeFieldBegin('dlqName', TType::STRING, 1);
      $xfer += $output->writeString($this->dlqName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sourceQueues !== null) {
      if (!is_array($this->sourceQueues)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sourceQueues', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->sourceQueues));
        {
          foreach ($this->sourceQueues as $iter15)
          {
            $xfer += $output->writeString($iter15);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListQueueRequest {
  static $_TSPEC;

  /**
   * The queue name prefix;
   * 
   * 
   * @var string
   */
  public $queueNamePrefix = "";

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueNamePrefix',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueNamePrefix'])) {
        $this->queueNamePrefix = $vals['queueNamePrefix'];
      }
    }
  }

  public function getName() {
    return 'ListQueueRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueNamePrefix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListQueueRequest');
    if ($this->queueNamePrefix !== null) {
      $xfer += $output->writeFieldBegin('queueNamePrefix', TType::STRING, 1);
      $xfer += $output->writeString($this->queueNamePrefix);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListQueueResponse {
  static $_TSPEC;

  /**
   * The queueName list with queueNamePrefix;
   * 
   * 
   * @var string[]
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'ListQueueResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->queueName = array();
            $_size16 = 0;
            $_etype19 = 0;
            $xfer += $input->readListBegin($_etype19, $_size16);
            for ($_i20 = 0; $_i20 < $_size16; ++$_i20)
            {
              $elem21 = null;
              $xfer += $input->readString($elem21);
              $this->queueName []= $elem21;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListQueueResponse');
    if ($this->queueName !== null) {
      if (!is_array($this->queueName)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('queueName', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->queueName));
        {
          foreach ($this->queueName as $iter22)
          {
            $xfer += $output->writeString($iter22);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SetPermissionRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $developerId = null;
  /**
   * @var int
   */
  public $permission = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'developerId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'permission',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['developerId'])) {
        $this->developerId = $vals['developerId'];
      }
      if (isset($vals['permission'])) {
        $this->permission = $vals['permission'];
      }
    }
  }

  public function getName() {
    return 'SetPermissionRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->developerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->permission);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SetPermissionRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->developerId !== null) {
      $xfer += $output->writeFieldBegin('developerId', TType::STRING, 2);
      $xfer += $output->writeString($this->developerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->permission !== null) {
      $xfer += $output->writeFieldBegin('permission', TType::I32, 3);
      $xfer += $output->writeI32($this->permission);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class RevokePermissionRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $developerId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'developerId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['developerId'])) {
        $this->developerId = $vals['developerId'];
      }
    }
  }

  public function getName() {
    return 'RevokePermissionRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->developerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RevokePermissionRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->developerId !== null) {
      $xfer += $output->writeFieldBegin('developerId', TType::STRING, 2);
      $xfer += $output->writeString($this->developerId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $permission = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'permission',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['permission'])) {
        $this->permission = $vals['permission'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->permission);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionResponse');
    if ($this->permission !== null) {
      $xfer += $output->writeFieldBegin('permission', TType::I32, 1);
      $xfer += $output->writeI32($this->permission);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionForIdRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $developerId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'developerId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['developerId'])) {
        $this->developerId = $vals['developerId'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionForIdRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->developerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionForIdRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->developerId !== null) {
      $xfer += $output->writeFieldBegin('developerId', TType::STRING, 2);
      $xfer += $output->writeString($this->developerId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryPermissionForIdResponse {
  static $_TSPEC;

  /**
   * @var int
   */
  public $permission = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'permission',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['permission'])) {
        $this->permission = $vals['permission'];
      }
    }
  }

  public function getName() {
    return 'QueryPermissionForIdResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->permission);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryPermissionForIdResponse');
    if ($this->permission !== null) {
      $xfer += $output->writeFieldBegin('permission', TType::I32, 1);
      $xfer += $output->writeI32($this->permission);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListPermissionsRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'ListPermissionsRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListPermissionsRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListPermissionsResponse {
  static $_TSPEC;

  /**
   * @var array
   */
  public $permissionList = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'permissionList',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['permissionList'])) {
        $this->permissionList = $vals['permissionList'];
      }
    }
  }

  public function getName() {
    return 'ListPermissionsResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->permissionList = array();
            $_size23 = 0;
            $_ktype24 = 0;
            $_vtype25 = 0;
            $xfer += $input->readMapBegin($_ktype24, $_vtype25, $_size23);
            for ($_i27 = 0; $_i27 < $_size23; ++$_i27)
            {
              $key28 = '';
              $val29 = 0;
              $xfer += $input->readString($key28);
              $xfer += $input->readI32($val29);
              $this->permissionList[$key28] = $val29;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListPermissionsResponse');
    if ($this->permissionList !== null) {
      if (!is_array($this->permissionList)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('permissionList', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->permissionList));
        {
          foreach ($this->permissionList as $kiter30 => $viter31)
          {
            $xfer += $output->writeString($kiter30);
            $xfer += $output->writeI32($viter31);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateTagRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $tagName = null;
  /**
   * @var int
   */
  public $startTimestamp = null;
  /**
   * @var int
   */
  public $readQPSQuota = null;
  /**
   * @var string
   */
  public $attributeName = null;
  /**
   * @var \EMQ\Message\MessageAttribute
   */
  public $attributeValue = null;
  /**
   * @var array
   */
  public $userAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'startTimestamp',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'readQPSQuota',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'attributeName',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'attributeValue',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Message\MessageAttribute',
          ),
        7 => array(
          'var' => 'userAttributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
      if (isset($vals['startTimestamp'])) {
        $this->startTimestamp = $vals['startTimestamp'];
      }
      if (isset($vals['readQPSQuota'])) {
        $this->readQPSQuota = $vals['readQPSQuota'];
      }
      if (isset($vals['attributeName'])) {
        $this->attributeName = $vals['attributeName'];
      }
      if (isset($vals['attributeValue'])) {
        $this->attributeValue = $vals['attributeValue'];
      }
      if (isset($vals['userAttributes'])) {
        $this->userAttributes = $vals['userAttributes'];
      }
    }
  }

  public function getName() {
    return 'CreateTagRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->readQPSQuota);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->attributeName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->attributeValue = new \EMQ\Message\MessageAttribute();
            $xfer += $this->attributeValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->userAttributes = array();
            $_size32 = 0;
            $_ktype33 = 0;
            $_vtype34 = 0;
            $xfer += $input->readMapBegin($_ktype33, $_vtype34, $_size32);
            for ($_i36 = 0; $_i36 < $_size32; ++$_i36)
            {
              $key37 = '';
              $val38 = '';
              $xfer += $input->readString($key37);
              $xfer += $input->readString($val38);
              $this->userAttributes[$key37] = $val38;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateTagRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 2);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startTimestamp !== null) {
      $xfer += $output->writeFieldBegin('startTimestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->startTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->readQPSQuota !== null) {
      $xfer += $output->writeFieldBegin('readQPSQuota', TType::I64, 4);
      $xfer += $output->writeI64($this->readQPSQuota);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributeName !== null) {
      $xfer += $output->writeFieldBegin('attributeName', TType::STRING, 5);
      $xfer += $output->writeString($this->attributeName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributeValue !== null) {
      if (!is_object($this->attributeValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributeValue', TType::STRUCT, 6);
      $xfer += $this->attributeValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userAttributes !== null) {
      if (!is_array($this->userAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userAttributes', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->userAttributes));
        {
          foreach ($this->userAttributes as $kiter39 => $viter40)
          {
            $xfer += $output->writeString($kiter39);
            $xfer += $output->writeString($viter40);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateTagResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $tagName = null;
  /**
   * @var int
   */
  public $startTimestamp = null;
  /**
   * @var int
   */
  public $readQPSQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'startTimestamp',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'readQPSQuota',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
      if (isset($vals['startTimestamp'])) {
        $this->startTimestamp = $vals['startTimestamp'];
      }
      if (isset($vals['readQPSQuota'])) {
        $this->readQPSQuota = $vals['readQPSQuota'];
      }
    }
  }

  public function getName() {
    return 'CreateTagResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->readQPSQuota);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateTagResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 2);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startTimestamp !== null) {
      $xfer += $output->writeFieldBegin('startTimestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->startTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->readQPSQuota !== null) {
      $xfer += $output->writeFieldBegin('readQPSQuota', TType::I64, 4);
      $xfer += $output->writeI64($this->readQPSQuota);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DeleteTagRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $tagName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
    }
  }

  public function getName() {
    return 'DeleteTagRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeleteTagRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 2);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetTagInfoRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $tagName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
    }
  }

  public function getName() {
    return 'GetTagInfoRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetTagInfoRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 2);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetTagInfoResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string
   */
  public $tagName = null;
  /**
   * @var \EMQ\Queue\QueueState
   */
  public $tagState = null;
  /**
   * @var int
   */
  public $startTimestamp = null;
  /**
   * @var int
   */
  public $readQPSQuota = null;
  /**
   * @var string
   */
  public $attributeName = null;
  /**
   * @var \EMQ\Message\MessageAttribute
   */
  public $attributeValue = null;
  /**
   * @var array
   */
  public $userAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tagState',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Queue\QueueState',
          ),
        4 => array(
          'var' => 'startTimestamp',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'readQPSQuota',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'attributeName',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'attributeValue',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Message\MessageAttribute',
          ),
        8 => array(
          'var' => 'userAttributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
      if (isset($vals['tagState'])) {
        $this->tagState = $vals['tagState'];
      }
      if (isset($vals['startTimestamp'])) {
        $this->startTimestamp = $vals['startTimestamp'];
      }
      if (isset($vals['readQPSQuota'])) {
        $this->readQPSQuota = $vals['readQPSQuota'];
      }
      if (isset($vals['attributeName'])) {
        $this->attributeName = $vals['attributeName'];
      }
      if (isset($vals['attributeValue'])) {
        $this->attributeValue = $vals['attributeValue'];
      }
      if (isset($vals['userAttributes'])) {
        $this->userAttributes = $vals['userAttributes'];
      }
    }
  }

  public function getName() {
    return 'GetTagInfoResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->tagState = new \EMQ\Queue\QueueState();
            $xfer += $this->tagState->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->readQPSQuota);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->attributeName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->attributeValue = new \EMQ\Message\MessageAttribute();
            $xfer += $this->attributeValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::MAP) {
            $this->userAttributes = array();
            $_size41 = 0;
            $_ktype42 = 0;
            $_vtype43 = 0;
            $xfer += $input->readMapBegin($_ktype42, $_vtype43, $_size41);
            for ($_i45 = 0; $_i45 < $_size41; ++$_i45)
            {
              $key46 = '';
              $val47 = '';
              $xfer += $input->readString($key46);
              $xfer += $input->readString($val47);
              $this->userAttributes[$key46] = $val47;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetTagInfoResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 2);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagState !== null) {
      if (!is_object($this->tagState)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tagState', TType::STRUCT, 3);
      $xfer += $this->tagState->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startTimestamp !== null) {
      $xfer += $output->writeFieldBegin('startTimestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->startTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->readQPSQuota !== null) {
      $xfer += $output->writeFieldBegin('readQPSQuota', TType::I64, 5);
      $xfer += $output->writeI64($this->readQPSQuota);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributeName !== null) {
      $xfer += $output->writeFieldBegin('attributeName', TType::STRING, 6);
      $xfer += $output->writeString($this->attributeName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributeValue !== null) {
      if (!is_object($this->attributeValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributeValue', TType::STRUCT, 7);
      $xfer += $this->attributeValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userAttributes !== null) {
      if (!is_array($this->userAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userAttributes', TType::MAP, 8);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->userAttributes));
        {
          foreach ($this->userAttributes as $kiter48 => $viter49)
          {
            $xfer += $output->writeString($kiter48);
            $xfer += $output->writeString($viter49);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListTagRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
    }
  }

  public function getName() {
    return 'ListTagRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListTagRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListTagResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var string[]
   */
  public $tagName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tagName',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
    }
  }

  public function getName() {
    return 'ListTagResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->tagName = array();
            $_size50 = 0;
            $_etype53 = 0;
            $xfer += $input->readListBegin($_etype53, $_size50);
            for ($_i54 = 0; $_i54 < $_size50; ++$_i54)
            {
              $elem55 = null;
              $xfer += $input->readString($elem55);
              $this->tagName []= $elem55;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListTagResponse');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      if (!is_array($this->tagName)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tagName', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->tagName));
        {
          foreach ($this->tagName as $iter56)
          {
            $xfer += $output->writeString($iter56);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryMetricRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $queueName = null;
  /**
   * @var int
   */
  public $startTime = null;
  /**
   * @var int
   */
  public $endTime = null;
  /**
   * metric name
   * 
   * 
   * @var string
   */
  public $metrics = null;
  /**
   * tags, reference to opentsdb,
   * e.g. <"type", "">
   * 
   * 
   * @var array
   */
  public $tags = null;
  /**
   * data aggregator, reference to opentsdb,
   * e.g. max, avg, min
   * 
   * 
   * @var string
   */
  public $aggregator = null;
  /**
   * similar to aggregator above
   * 
   * 
   * @var string
   */
  public $downsampleAggregator = null;
  /**
   * @var int
   */
  public $downsampleInterval = null;
  /**
   * downsample interval unit, reference to opentsdb,
   * e.g. ms(milliseconds), s(seconds), d(day)
   * 
   * 
   * @var string
   */
  public $downsampleTimeUnit = null;
  /**
   * @var bool
   */
  public $calRate = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startTime',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'endTime',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'metrics',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'tags',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'aggregator',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'downsampleAggregator',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'downsampleInterval',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'downsampleTimeUnit',
          'type' => TType::STRING,
          ),
        10 => array(
          'var' => 'calRate',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['startTime'])) {
        $this->startTime = $vals['startTime'];
      }
      if (isset($vals['endTime'])) {
        $this->endTime = $vals['endTime'];
      }
      if (isset($vals['metrics'])) {
        $this->metrics = $vals['metrics'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['aggregator'])) {
        $this->aggregator = $vals['aggregator'];
      }
      if (isset($vals['downsampleAggregator'])) {
        $this->downsampleAggregator = $vals['downsampleAggregator'];
      }
      if (isset($vals['downsampleInterval'])) {
        $this->downsampleInterval = $vals['downsampleInterval'];
      }
      if (isset($vals['downsampleTimeUnit'])) {
        $this->downsampleTimeUnit = $vals['downsampleTimeUnit'];
      }
      if (isset($vals['calRate'])) {
        $this->calRate = $vals['calRate'];
      }
    }
  }

  public function getName() {
    return 'QueryMetricRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->endTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->metrics);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->tags = array();
            $_size57 = 0;
            $_ktype58 = 0;
            $_vtype59 = 0;
            $xfer += $input->readMapBegin($_ktype58, $_vtype59, $_size57);
            for ($_i61 = 0; $_i61 < $_size57; ++$_i61)
            {
              $key62 = '';
              $val63 = '';
              $xfer += $input->readString($key62);
              $xfer += $input->readString($val63);
              $this->tags[$key62] = $val63;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->aggregator);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->downsampleAggregator);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->downsampleInterval);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->downsampleTimeUnit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->calRate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryMetricRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startTime !== null) {
      $xfer += $output->writeFieldBegin('startTime', TType::I64, 2);
      $xfer += $output->writeI64($this->startTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endTime !== null) {
      $xfer += $output->writeFieldBegin('endTime', TType::I64, 3);
      $xfer += $output->writeI64($this->endTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->metrics !== null) {
      $xfer += $output->writeFieldBegin('metrics', TType::STRING, 4);
      $xfer += $output->writeString($this->metrics);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->tags));
        {
          foreach ($this->tags as $kiter64 => $viter65)
          {
            $xfer += $output->writeString($kiter64);
            $xfer += $output->writeString($viter65);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->aggregator !== null) {
      $xfer += $output->writeFieldBegin('aggregator', TType::STRING, 6);
      $xfer += $output->writeString($this->aggregator);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->downsampleAggregator !== null) {
      $xfer += $output->writeFieldBegin('downsampleAggregator', TType::STRING, 7);
      $xfer += $output->writeString($this->downsampleAggregator);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->downsampleInterval !== null) {
      $xfer += $output->writeFieldBegin('downsampleInterval', TType::I32, 8);
      $xfer += $output->writeI32($this->downsampleInterval);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->downsampleTimeUnit !== null) {
      $xfer += $output->writeFieldBegin('downsampleTimeUnit', TType::STRING, 9);
      $xfer += $output->writeString($this->downsampleTimeUnit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->calRate !== null) {
      $xfer += $output->writeFieldBegin('calRate', TType::BOOL, 10);
      $xfer += $output->writeBool($this->calRate);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * metrics time series data
 */
class TimeSeriesData {
  static $_TSPEC;

  /**
   * metric name
   * 
   * @var string
   */
  public $metric = null;
  /**
   * tags
   * 
   * @var array
   */
  public $tags = null;
  /**
   * data, {timestamp => value}
   * 
   * @var array
   */
  public $data = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'metric',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tags',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'data',
          'type' => TType::MAP,
          'ktype' => TType::I64,
          'vtype' => TType::DOUBLE,
          'key' => array(
            'type' => TType::I64,
          ),
          'val' => array(
            'type' => TType::DOUBLE,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['metric'])) {
        $this->metric = $vals['metric'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['data'])) {
        $this->data = $vals['data'];
      }
    }
  }

  public function getName() {
    return 'TimeSeriesData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->metric);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->tags = array();
            $_size66 = 0;
            $_ktype67 = 0;
            $_vtype68 = 0;
            $xfer += $input->readMapBegin($_ktype67, $_vtype68, $_size66);
            for ($_i70 = 0; $_i70 < $_size66; ++$_i70)
            {
              $key71 = '';
              $val72 = '';
              $xfer += $input->readString($key71);
              $xfer += $input->readString($val72);
              $this->tags[$key71] = $val72;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->data = array();
            $_size73 = 0;
            $_ktype74 = 0;
            $_vtype75 = 0;
            $xfer += $input->readMapBegin($_ktype74, $_vtype75, $_size73);
            for ($_i77 = 0; $_i77 < $_size73; ++$_i77)
            {
              $key78 = 0;
              $val79 = 0.0;
              $xfer += $input->readI64($key78);
              $xfer += $input->readDouble($val79);
              $this->data[$key78] = $val79;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TimeSeriesData');
    if ($this->metric !== null) {
      $xfer += $output->writeFieldBegin('metric', TType::STRING, 1);
      $xfer += $output->writeString($this->metric);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->tags));
        {
          foreach ($this->tags as $kiter80 => $viter81)
          {
            $xfer += $output->writeString($kiter80);
            $xfer += $output->writeString($viter81);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->data !== null) {
      if (!is_array($this->data)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('data', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::I64, TType::DOUBLE, count($this->data));
        {
          foreach ($this->data as $kiter82 => $viter83)
          {
            $xfer += $output->writeI64($kiter82);
            $xfer += $output->writeDouble($viter83);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


