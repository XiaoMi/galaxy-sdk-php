<?php
namespace EMQ\Message;

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * Copyright 2015, Xiaomi.
 * All rights reserved.
 * Author: shenyuannan@xiaomi.com
 */
class MessageAttribute {
  static $_TSPEC;

  /**
   * must start with "STRING" or "BINARY", with an optional "." and a user-defined sub-type
   * like "STRING.INTEGER" or "BINARY.JPEG"
   * do not contain characters excepts alphabets, digits or "."
   * 
   * 
   * @var string
   */
  public $type = null;
  /**
   * must be set if type is "STRING"
   * 
   * 
   * @var string
   */
  public $stringValue = null;
  /**
   * must be set if type is "BINARY"
   * 
   * 
   * @var string
   */
  public $binaryValue = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'stringValue',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'binaryValue',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['stringValue'])) {
        $this->stringValue = $vals['stringValue'];
      }
      if (isset($vals['binaryValue'])) {
        $this->binaryValue = $vals['binaryValue'];
      }
    }
  }

  public function getName() {
    return 'MessageAttribute';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stringValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->binaryValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MessageAttribute');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::STRING, 1);
      $xfer += $output->writeString($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stringValue !== null) {
      $xfer += $output->writeFieldBegin('stringValue', TType::STRING, 2);
      $xfer += $output->writeString($this->stringValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binaryValue !== null) {
      $xfer += $output->writeFieldBegin('binaryValue', TType::STRING, 3);
      $xfer += $output->writeString($this->binaryValue);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SendMessageRequest {
  static $_TSPEC;

  /**
   * Queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * Message body;
   * 
   * 
   * @var string
   */
  public $messageBody = null;
  /**
   * Delay seconds for this message, this will overwrite delaySecond of this
   * queue, default 0s (0s ~ 15min);
   * 
   * 
   * @var int
   */
  public $delaySeconds = null;
  /**
   * Invisibility seconds for this message, this will overwrite
   * invisibilitySeconds of this queue, default 30s (2s ~ 12hour);
   * 
   * 
   * @var int
   */
  public $invisibilitySeconds = null;
  /**
   * User-defined attributes attached to message
   * 
   * 
   * @var array
   */
  public $messageAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'messageBody',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'delaySeconds',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'invisibilitySeconds',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'messageAttributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\EMQ\Message\MessageAttribute',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['messageBody'])) {
        $this->messageBody = $vals['messageBody'];
      }
      if (isset($vals['delaySeconds'])) {
        $this->delaySeconds = $vals['delaySeconds'];
      }
      if (isset($vals['invisibilitySeconds'])) {
        $this->invisibilitySeconds = $vals['invisibilitySeconds'];
      }
      if (isset($vals['messageAttributes'])) {
        $this->messageAttributes = $vals['messageAttributes'];
      }
    }
  }

  public function getName() {
    return 'SendMessageRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageBody);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->delaySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->invisibilitySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->messageAttributes = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = '';
              $val6 = new \EMQ\Message\MessageAttribute();
              $xfer += $input->readString($key5);
              $val6 = new \EMQ\Message\MessageAttribute();
              $xfer += $val6->read($input);
              $this->messageAttributes[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SendMessageRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageBody !== null) {
      $xfer += $output->writeFieldBegin('messageBody', TType::STRING, 2);
      $xfer += $output->writeString($this->messageBody);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delaySeconds !== null) {
      $xfer += $output->writeFieldBegin('delaySeconds', TType::I32, 3);
      $xfer += $output->writeI32($this->delaySeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->invisibilitySeconds !== null) {
      $xfer += $output->writeFieldBegin('invisibilitySeconds', TType::I32, 4);
      $xfer += $output->writeI32($this->invisibilitySeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageAttributes !== null) {
      if (!is_array($this->messageAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('messageAttributes', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->messageAttributes));
        {
          foreach ($this->messageAttributes as $kiter7 => $viter8)
          {
            $xfer += $output->writeString($kiter7);
            $xfer += $viter8->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SendMessageResponse {
  static $_TSPEC;

  /**
   * MessageID for the send message
   * 
   * 
   * @var string
   */
  public $messageID = null;
  /**
   * Length of message body
   * 
   * 
   * @var int
   */
  public $bodyLength = null;
  /**
   * MD5 string of the message body
   * 
   * 
   * @var string
   */
  public $bodyMd5 = null;
  /**
   * timestamp when the message arrived servers
   * 
   * 
   * @var int
   */
  public $sendTimestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageID',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'bodyLength',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'bodyMd5',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'sendTimestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageID'])) {
        $this->messageID = $vals['messageID'];
      }
      if (isset($vals['bodyLength'])) {
        $this->bodyLength = $vals['bodyLength'];
      }
      if (isset($vals['bodyMd5'])) {
        $this->bodyMd5 = $vals['bodyMd5'];
      }
      if (isset($vals['sendTimestamp'])) {
        $this->sendTimestamp = $vals['sendTimestamp'];
      }
    }
  }

  public function getName() {
    return 'SendMessageResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageID);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->bodyLength);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bodyMd5);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->sendTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SendMessageResponse');
    if ($this->messageID !== null) {
      $xfer += $output->writeFieldBegin('messageID', TType::STRING, 1);
      $xfer += $output->writeString($this->messageID);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bodyLength !== null) {
      $xfer += $output->writeFieldBegin('bodyLength', TType::I32, 2);
      $xfer += $output->writeI32($this->bodyLength);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bodyMd5 !== null) {
      $xfer += $output->writeFieldBegin('bodyMd5', TType::STRING, 3);
      $xfer += $output->writeString($this->bodyMd5);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sendTimestamp !== null) {
      $xfer += $output->writeFieldBegin('sendTimestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->sendTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SendMessageBatchRequestEntry {
  static $_TSPEC;

  /**
   * The identifier for this particular receipt handle;
   * Using to identify the result in response;
   * Need to be unique within one batch
   * 
   * 
   * @var string
   */
  public $entryId = null;
  /**
   * Message body;
   * 
   * 
   * @var string
   */
  public $messageBody = null;
  /**
   * Delay seconds for this message, this will overwrite delaySecond of this
   * queue, default 0s (0s ~ 15min);
   * 
   * 
   * @var int
   */
  public $delaySeconds = null;
  /**
   * Invisibility seconds for this message, this will overwrite
   * invisibilitySeconds of this queue, default 30s (2s ~ 12hour);
   * 
   * 
   * @var int
   */
  public $invisibilitySeconds = null;
  /**
   * User-defined attributes attached to message
   * 
   * 
   * @var array
   */
  public $messageAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'entryId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'messageBody',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'delaySeconds',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'invisibilitySeconds',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'messageAttributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\EMQ\Message\MessageAttribute',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['entryId'])) {
        $this->entryId = $vals['entryId'];
      }
      if (isset($vals['messageBody'])) {
        $this->messageBody = $vals['messageBody'];
      }
      if (isset($vals['delaySeconds'])) {
        $this->delaySeconds = $vals['delaySeconds'];
      }
      if (isset($vals['invisibilitySeconds'])) {
        $this->invisibilitySeconds = $vals['invisibilitySeconds'];
      }
      if (isset($vals['messageAttributes'])) {
        $this->messageAttributes = $vals['messageAttributes'];
      }
    }
  }

  public function getName() {
    return 'SendMessageBatchRequestEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->entryId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageBody);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->delaySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->invisibilitySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->messageAttributes = array();
            $_size9 = 0;
            $_ktype10 = 0;
            $_vtype11 = 0;
            $xfer += $input->readMapBegin($_ktype10, $_vtype11, $_size9);
            for ($_i13 = 0; $_i13 < $_size9; ++$_i13)
            {
              $key14 = '';
              $val15 = new \EMQ\Message\MessageAttribute();
              $xfer += $input->readString($key14);
              $val15 = new \EMQ\Message\MessageAttribute();
              $xfer += $val15->read($input);
              $this->messageAttributes[$key14] = $val15;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SendMessageBatchRequestEntry');
    if ($this->entryId !== null) {
      $xfer += $output->writeFieldBegin('entryId', TType::STRING, 1);
      $xfer += $output->writeString($this->entryId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageBody !== null) {
      $xfer += $output->writeFieldBegin('messageBody', TType::STRING, 2);
      $xfer += $output->writeString($this->messageBody);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delaySeconds !== null) {
      $xfer += $output->writeFieldBegin('delaySeconds', TType::I32, 3);
      $xfer += $output->writeI32($this->delaySeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->invisibilitySeconds !== null) {
      $xfer += $output->writeFieldBegin('invisibilitySeconds', TType::I32, 4);
      $xfer += $output->writeI32($this->invisibilitySeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageAttributes !== null) {
      if (!is_array($this->messageAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('messageAttributes', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->messageAttributes));
        {
          foreach ($this->messageAttributes as $kiter16 => $viter17)
          {
            $xfer += $output->writeString($kiter16);
            $xfer += $viter17->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SendMessageBatchRequest {
  static $_TSPEC;

  /**
   * Queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * List of SendMessageBatchRequestEntry;
   * 
   * 
   * @var \EMQ\Message\SendMessageBatchRequestEntry[]
   */
  public $sendMessageBatchRequestEntryList = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'sendMessageBatchRequestEntryList',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\EMQ\Message\SendMessageBatchRequestEntry',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['sendMessageBatchRequestEntryList'])) {
        $this->sendMessageBatchRequestEntryList = $vals['sendMessageBatchRequestEntryList'];
      }
    }
  }

  public function getName() {
    return 'SendMessageBatchRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->sendMessageBatchRequestEntryList = array();
            $_size18 = 0;
            $_etype21 = 0;
            $xfer += $input->readListBegin($_etype21, $_size18);
            for ($_i22 = 0; $_i22 < $_size18; ++$_i22)
            {
              $elem23 = null;
              $elem23 = new \EMQ\Message\SendMessageBatchRequestEntry();
              $xfer += $elem23->read($input);
              $this->sendMessageBatchRequestEntryList []= $elem23;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SendMessageBatchRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sendMessageBatchRequestEntryList !== null) {
      if (!is_array($this->sendMessageBatchRequestEntryList)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sendMessageBatchRequestEntryList', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->sendMessageBatchRequestEntryList));
        {
          foreach ($this->sendMessageBatchRequestEntryList as $iter24)
          {
            $xfer += $iter24->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SendMessageBatchResponseEntry {
  static $_TSPEC;

  /**
   * corresponding to the entryId in request
   * 
   * 
   * @var string
   */
  public $entryId = null;
  /**
   * MessageID for the send message
   * 
   * 
   * @var string
   */
  public $messageID = null;
  /**
   * Length of message body
   * 
   * 
   * @var int
   */
  public $bodyLength = null;
  /**
   * MD5 string of the message body
   * 
   * 
   * @var string
   */
  public $bodyMd5 = null;
  /**
   * timestamp when the message arrived servers
   * 
   * 
   * @var int
   */
  public $sendTimestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'entryId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'messageID',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'bodyLength',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'bodyMd5',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'sendTimestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['entryId'])) {
        $this->entryId = $vals['entryId'];
      }
      if (isset($vals['messageID'])) {
        $this->messageID = $vals['messageID'];
      }
      if (isset($vals['bodyLength'])) {
        $this->bodyLength = $vals['bodyLength'];
      }
      if (isset($vals['bodyMd5'])) {
        $this->bodyMd5 = $vals['bodyMd5'];
      }
      if (isset($vals['sendTimestamp'])) {
        $this->sendTimestamp = $vals['sendTimestamp'];
      }
    }
  }

  public function getName() {
    return 'SendMessageBatchResponseEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->entryId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageID);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->bodyLength);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bodyMd5);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->sendTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SendMessageBatchResponseEntry');
    if ($this->entryId !== null) {
      $xfer += $output->writeFieldBegin('entryId', TType::STRING, 1);
      $xfer += $output->writeString($this->entryId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageID !== null) {
      $xfer += $output->writeFieldBegin('messageID', TType::STRING, 2);
      $xfer += $output->writeString($this->messageID);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bodyLength !== null) {
      $xfer += $output->writeFieldBegin('bodyLength', TType::I32, 3);
      $xfer += $output->writeI32($this->bodyLength);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bodyMd5 !== null) {
      $xfer += $output->writeFieldBegin('bodyMd5', TType::STRING, 4);
      $xfer += $output->writeString($this->bodyMd5);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sendTimestamp !== null) {
      $xfer += $output->writeFieldBegin('sendTimestamp', TType::I64, 5);
      $xfer += $output->writeI64($this->sendTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MessageBatchErrorEntry {
  static $_TSPEC;

  /**
   * corresponding to the entryId/receiptHandle in request
   * 
   * 
   * @var string
   */
  public $id = null;
  /**
   * The exception indicate why the request entry failed
   * 
   * 
   * @var \EMQ\Common\GalaxyEmqServiceException
   */
  public $reason = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'reason',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Common\GalaxyEmqServiceException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['reason'])) {
        $this->reason = $vals['reason'];
      }
    }
  }

  public function getName() {
    return 'MessageBatchErrorEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->reason = new \EMQ\Common\GalaxyEmqServiceException();
            $xfer += $this->reason->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MessageBatchErrorEntry');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reason !== null) {
      $xfer += $output->writeFieldBegin('reason', TType::STRUCT, 2);
      $xfer += $this->reason->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SendMessageBatchResponse {
  static $_TSPEC;

  /**
   * The successful results list;
   * 
   * 
   * @var \EMQ\Message\SendMessageBatchResponseEntry[]
   */
  public $successful = null;
  /**
   * Failed results list;
   * 
   * 
   * @var \EMQ\Message\MessageBatchErrorEntry[]
   */
  public $failed = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'successful',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\EMQ\Message\SendMessageBatchResponseEntry',
            ),
          ),
        2 => array(
          'var' => 'failed',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\EMQ\Message\MessageBatchErrorEntry',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['successful'])) {
        $this->successful = $vals['successful'];
      }
      if (isset($vals['failed'])) {
        $this->failed = $vals['failed'];
      }
    }
  }

  public function getName() {
    return 'SendMessageBatchResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->successful = array();
            $_size25 = 0;
            $_etype28 = 0;
            $xfer += $input->readListBegin($_etype28, $_size25);
            for ($_i29 = 0; $_i29 < $_size25; ++$_i29)
            {
              $elem30 = null;
              $elem30 = new \EMQ\Message\SendMessageBatchResponseEntry();
              $xfer += $elem30->read($input);
              $this->successful []= $elem30;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->failed = array();
            $_size31 = 0;
            $_etype34 = 0;
            $xfer += $input->readListBegin($_etype34, $_size31);
            for ($_i35 = 0; $_i35 < $_size31; ++$_i35)
            {
              $elem36 = null;
              $elem36 = new \EMQ\Message\MessageBatchErrorEntry();
              $xfer += $elem36->read($input);
              $this->failed []= $elem36;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SendMessageBatchResponse');
    if ($this->successful !== null) {
      if (!is_array($this->successful)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('successful', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->successful));
        {
          foreach ($this->successful as $iter37)
          {
            $xfer += $iter37->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->failed !== null) {
      if (!is_array($this->failed)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('failed', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->failed));
        {
          foreach ($this->failed as $iter38)
          {
            $xfer += $iter38->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ReceiveMessageRequest {
  static $_TSPEC;

  /**
   * Queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * Max receive message number, default 100 (1 ~ 100);
   * 
   * 
   * @var int
   */
  public $maxReceiveMessageNumber = 100;
  /**
   * Max receive message wait seconds, default 20s (0 ~ 20), 0s means no wait;
   * 
   * 
   * @var int
   */
  public $maxReceiveMessageWaitSeconds = 0;
  /**
   * Attribute name to match
   * case-sensitive
   * 
   * 
   * @var string
   */
  public $attributeName = null;
  /**
   * Attribute value to match, corresponding to attributeName
   * case-sensitive
   * 
   * 
   * @var \EMQ\Message\MessageAttribute
   */
  public $attributeValue = null;
  /**
   * If this field is not_set/null/empty, default queue tag will be used
   * 
   * 
   * @var string
   */
  public $tagName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'maxReceiveMessageNumber',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'maxReceiveMessageWaitSeconds',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'attributeName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'attributeValue',
          'type' => TType::STRUCT,
          'class' => '\EMQ\Message\MessageAttribute',
          ),
        6 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['maxReceiveMessageNumber'])) {
        $this->maxReceiveMessageNumber = $vals['maxReceiveMessageNumber'];
      }
      if (isset($vals['maxReceiveMessageWaitSeconds'])) {
        $this->maxReceiveMessageWaitSeconds = $vals['maxReceiveMessageWaitSeconds'];
      }
      if (isset($vals['attributeName'])) {
        $this->attributeName = $vals['attributeName'];
      }
      if (isset($vals['attributeValue'])) {
        $this->attributeValue = $vals['attributeValue'];
      }
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
    }
  }

  public function getName() {
    return 'ReceiveMessageRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->maxReceiveMessageNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->maxReceiveMessageWaitSeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->attributeName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->attributeValue = new \EMQ\Message\MessageAttribute();
            $xfer += $this->attributeValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReceiveMessageRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxReceiveMessageNumber !== null) {
      $xfer += $output->writeFieldBegin('maxReceiveMessageNumber', TType::I32, 2);
      $xfer += $output->writeI32($this->maxReceiveMessageNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxReceiveMessageWaitSeconds !== null) {
      $xfer += $output->writeFieldBegin('maxReceiveMessageWaitSeconds', TType::I32, 3);
      $xfer += $output->writeI32($this->maxReceiveMessageWaitSeconds);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributeName !== null) {
      $xfer += $output->writeFieldBegin('attributeName', TType::STRING, 4);
      $xfer += $output->writeString($this->attributeName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributeValue !== null) {
      if (!is_object($this->attributeValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributeValue', TType::STRUCT, 5);
      $xfer += $this->attributeValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 6);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ReceiveMessageResponse {
  static $_TSPEC;

  /**
   * MessageID for the received message;
   * 
   * 
   * @var string
   */
  public $messageID = null;
  /**
   * Receipt Handle for the received message
   * Using when change visibility time/delete message
   * 
   * 
   * @var string
   */
  public $receiptHandle = null;
  /**
   * Message body for the received message;
   * 
   * 
   * @var string
   */
  public $messageBody = null;
  /**
   * Attributes of message, including:
   * - senderId
   * - messageLength
   * - md5OfBody
   * - sendTimestamp
   * - receiveTimestamp
   * - firstReceiveTimestamp
   * - receiveCount
   * 
   * If the message is received from a dead letter queue,
   * it has another four attributes:
   * - sourceQueueName
   * - sourceTag
   * - deadTimestamp
   * - originalMessageID
   * 
   * 
   * 
   * @var array
   */
  public $attributes = null;
  /**
   * User-defined attributes attached to message
   * 
   * 
   * @var array
   */
  public $messageAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'messageID',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'receiptHandle',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'messageBody',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'attributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'messageAttributes',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\EMQ\Message\MessageAttribute',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['messageID'])) {
        $this->messageID = $vals['messageID'];
      }
      if (isset($vals['receiptHandle'])) {
        $this->receiptHandle = $vals['receiptHandle'];
      }
      if (isset($vals['messageBody'])) {
        $this->messageBody = $vals['messageBody'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['messageAttributes'])) {
        $this->messageAttributes = $vals['messageAttributes'];
      }
    }
  }

  public function getName() {
    return 'ReceiveMessageResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageID);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->receiptHandle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->messageBody);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->attributes = array();
            $_size39 = 0;
            $_ktype40 = 0;
            $_vtype41 = 0;
            $xfer += $input->readMapBegin($_ktype40, $_vtype41, $_size39);
            for ($_i43 = 0; $_i43 < $_size39; ++$_i43)
            {
              $key44 = '';
              $val45 = '';
              $xfer += $input->readString($key44);
              $xfer += $input->readString($val45);
              $this->attributes[$key44] = $val45;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->messageAttributes = array();
            $_size46 = 0;
            $_ktype47 = 0;
            $_vtype48 = 0;
            $xfer += $input->readMapBegin($_ktype47, $_vtype48, $_size46);
            for ($_i50 = 0; $_i50 < $_size46; ++$_i50)
            {
              $key51 = '';
              $val52 = new \EMQ\Message\MessageAttribute();
              $xfer += $input->readString($key51);
              $val52 = new \EMQ\Message\MessageAttribute();
              $xfer += $val52->read($input);
              $this->messageAttributes[$key51] = $val52;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReceiveMessageResponse');
    if ($this->messageID !== null) {
      $xfer += $output->writeFieldBegin('messageID', TType::STRING, 1);
      $xfer += $output->writeString($this->messageID);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiptHandle !== null) {
      $xfer += $output->writeFieldBegin('receiptHandle', TType::STRING, 2);
      $xfer += $output->writeString($this->receiptHandle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageBody !== null) {
      $xfer += $output->writeFieldBegin('messageBody', TType::STRING, 3);
      $xfer += $output->writeString($this->messageBody);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_array($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->attributes));
        {
          foreach ($this->attributes as $kiter53 => $viter54)
          {
            $xfer += $output->writeString($kiter53);
            $xfer += $output->writeString($viter54);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->messageAttributes !== null) {
      if (!is_array($this->messageAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('messageAttributes', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->messageAttributes));
        {
          foreach ($this->messageAttributes as $kiter55 => $viter56)
          {
            $xfer += $output->writeString($kiter55);
            $xfer += $viter56->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ChangeMessageVisibilityRequest {
  static $_TSPEC;

  /**
   * Queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * receiptHandle for change visibility;
   * 
   * 
   * @var string
   */
  public $receiptHandle = null;
  /**
   * The extra invisibilitySeconds for this message (0s ~ 12hour)
   * 
   * 
   * @var int
   */
  public $invisibilitySeconds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'receiptHandle',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'invisibilitySeconds',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['receiptHandle'])) {
        $this->receiptHandle = $vals['receiptHandle'];
      }
      if (isset($vals['invisibilitySeconds'])) {
        $this->invisibilitySeconds = $vals['invisibilitySeconds'];
      }
    }
  }

  public function getName() {
    return 'ChangeMessageVisibilityRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->receiptHandle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->invisibilitySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChangeMessageVisibilityRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiptHandle !== null) {
      $xfer += $output->writeFieldBegin('receiptHandle', TType::STRING, 2);
      $xfer += $output->writeString($this->receiptHandle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->invisibilitySeconds !== null) {
      $xfer += $output->writeFieldBegin('invisibilitySeconds', TType::I32, 3);
      $xfer += $output->writeI32($this->invisibilitySeconds);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ChangeMessageVisibilityBatchRequestEntry {
  static $_TSPEC;

  /**
   * receiptHandle for change visibility;
   * 
   * 
   * @var string
   */
  public $receiptHandle = null;
  /**
   * The extra invisibilitySeconds for this message (0s ~ 12hour)
   * 
   * 
   * @var int
   */
  public $invisibilitySeconds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'receiptHandle',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'invisibilitySeconds',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['receiptHandle'])) {
        $this->receiptHandle = $vals['receiptHandle'];
      }
      if (isset($vals['invisibilitySeconds'])) {
        $this->invisibilitySeconds = $vals['invisibilitySeconds'];
      }
    }
  }

  public function getName() {
    return 'ChangeMessageVisibilityBatchRequestEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->receiptHandle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->invisibilitySeconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChangeMessageVisibilityBatchRequestEntry');
    if ($this->receiptHandle !== null) {
      $xfer += $output->writeFieldBegin('receiptHandle', TType::STRING, 1);
      $xfer += $output->writeString($this->receiptHandle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->invisibilitySeconds !== null) {
      $xfer += $output->writeFieldBegin('invisibilitySeconds', TType::I32, 2);
      $xfer += $output->writeI32($this->invisibilitySeconds);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ChangeMessageVisibilityBatchRequest {
  static $_TSPEC;

  /**
   * Queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * List of ChangeMessageVisibilityRequest;
   * 
   * 
   * @var \EMQ\Message\ChangeMessageVisibilityBatchRequestEntry[]
   */
  public $changeMessageVisibilityRequestEntryList = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'changeMessageVisibilityRequestEntryList',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\EMQ\Message\ChangeMessageVisibilityBatchRequestEntry',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['changeMessageVisibilityRequestEntryList'])) {
        $this->changeMessageVisibilityRequestEntryList = $vals['changeMessageVisibilityRequestEntryList'];
      }
    }
  }

  public function getName() {
    return 'ChangeMessageVisibilityBatchRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->changeMessageVisibilityRequestEntryList = array();
            $_size57 = 0;
            $_etype60 = 0;
            $xfer += $input->readListBegin($_etype60, $_size57);
            for ($_i61 = 0; $_i61 < $_size57; ++$_i61)
            {
              $elem62 = null;
              $elem62 = new \EMQ\Message\ChangeMessageVisibilityBatchRequestEntry();
              $xfer += $elem62->read($input);
              $this->changeMessageVisibilityRequestEntryList []= $elem62;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChangeMessageVisibilityBatchRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->changeMessageVisibilityRequestEntryList !== null) {
      if (!is_array($this->changeMessageVisibilityRequestEntryList)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('changeMessageVisibilityRequestEntryList', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->changeMessageVisibilityRequestEntryList));
        {
          foreach ($this->changeMessageVisibilityRequestEntryList as $iter63)
          {
            $xfer += $iter63->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ChangeMessageVisibilityBatchResponse {
  static $_TSPEC;

  /**
   * The successful receipt handle;
   * 
   * 
   * @var string[]
   */
  public $successful = null;
  /**
   * Failed results list;
   * Using receipt handle to index
   * 
   * 
   * @var \EMQ\Message\MessageBatchErrorEntry[]
   */
  public $failed = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'successful',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'failed',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\EMQ\Message\MessageBatchErrorEntry',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['successful'])) {
        $this->successful = $vals['successful'];
      }
      if (isset($vals['failed'])) {
        $this->failed = $vals['failed'];
      }
    }
  }

  public function getName() {
    return 'ChangeMessageVisibilityBatchResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->successful = array();
            $_size64 = 0;
            $_etype67 = 0;
            $xfer += $input->readListBegin($_etype67, $_size64);
            for ($_i68 = 0; $_i68 < $_size64; ++$_i68)
            {
              $elem69 = null;
              $xfer += $input->readString($elem69);
              $this->successful []= $elem69;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->failed = array();
            $_size70 = 0;
            $_etype73 = 0;
            $xfer += $input->readListBegin($_etype73, $_size70);
            for ($_i74 = 0; $_i74 < $_size70; ++$_i74)
            {
              $elem75 = null;
              $elem75 = new \EMQ\Message\MessageBatchErrorEntry();
              $xfer += $elem75->read($input);
              $this->failed []= $elem75;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChangeMessageVisibilityBatchResponse');
    if ($this->successful !== null) {
      if (!is_array($this->successful)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('successful', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->successful));
        {
          foreach ($this->successful as $iter76)
          {
            $xfer += $output->writeString($iter76);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->failed !== null) {
      if (!is_array($this->failed)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('failed', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->failed));
        {
          foreach ($this->failed as $iter77)
          {
            $xfer += $iter77->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DeleteMessageRequest {
  static $_TSPEC;

  /**
   * Queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * receipt handle of message to delete;
   * 
   * 
   * @var string
   */
  public $receiptHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'receiptHandle',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['receiptHandle'])) {
        $this->receiptHandle = $vals['receiptHandle'];
      }
    }
  }

  public function getName() {
    return 'DeleteMessageRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->receiptHandle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeleteMessageRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiptHandle !== null) {
      $xfer += $output->writeFieldBegin('receiptHandle', TType::STRING, 2);
      $xfer += $output->writeString($this->receiptHandle);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DeleteMessageBatchRequestEntry {
  static $_TSPEC;

  /**
   * receipt handle of message to delete;
   * 
   * 
   * @var string
   */
  public $receiptHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'receiptHandle',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['receiptHandle'])) {
        $this->receiptHandle = $vals['receiptHandle'];
      }
    }
  }

  public function getName() {
    return 'DeleteMessageBatchRequestEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->receiptHandle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeleteMessageBatchRequestEntry');
    if ($this->receiptHandle !== null) {
      $xfer += $output->writeFieldBegin('receiptHandle', TType::STRING, 1);
      $xfer += $output->writeString($this->receiptHandle);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DeleteMessageBatchRequest {
  static $_TSPEC;

  /**
   * Queue name;
   * 
   * 
   * @var string
   */
  public $queueName = null;
  /**
   * List of DeleteMessageRequest;
   * 
   * 
   * @var \EMQ\Message\DeleteMessageBatchRequestEntry[]
   */
  public $deleteMessageBatchRequestEntryList = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'queueName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'deleteMessageBatchRequestEntryList',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\EMQ\Message\DeleteMessageBatchRequestEntry',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['queueName'])) {
        $this->queueName = $vals['queueName'];
      }
      if (isset($vals['deleteMessageBatchRequestEntryList'])) {
        $this->deleteMessageBatchRequestEntryList = $vals['deleteMessageBatchRequestEntryList'];
      }
    }
  }

  public function getName() {
    return 'DeleteMessageBatchRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queueName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->deleteMessageBatchRequestEntryList = array();
            $_size78 = 0;
            $_etype81 = 0;
            $xfer += $input->readListBegin($_etype81, $_size78);
            for ($_i82 = 0; $_i82 < $_size78; ++$_i82)
            {
              $elem83 = null;
              $elem83 = new \EMQ\Message\DeleteMessageBatchRequestEntry();
              $xfer += $elem83->read($input);
              $this->deleteMessageBatchRequestEntryList []= $elem83;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeleteMessageBatchRequest');
    if ($this->queueName !== null) {
      $xfer += $output->writeFieldBegin('queueName', TType::STRING, 1);
      $xfer += $output->writeString($this->queueName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteMessageBatchRequestEntryList !== null) {
      if (!is_array($this->deleteMessageBatchRequestEntryList)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('deleteMessageBatchRequestEntryList', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->deleteMessageBatchRequestEntryList));
        {
          foreach ($this->deleteMessageBatchRequestEntryList as $iter84)
          {
            $xfer += $iter84->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DeleteMessageBatchResponse {
  static $_TSPEC;

  /**
   * The successful receipt handle;
   * 
   * 
   * @var string[]
   */
  public $successful = null;
  /**
   * Failed results list;
   * Using receipt handle to index
   * 
   * 
   * @var \EMQ\Message\MessageBatchErrorEntry[]
   */
  public $failed = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'successful',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'failed',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\EMQ\Message\MessageBatchErrorEntry',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['successful'])) {
        $this->successful = $vals['successful'];
      }
      if (isset($vals['failed'])) {
        $this->failed = $vals['failed'];
      }
    }
  }

  public function getName() {
    return 'DeleteMessageBatchResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->successful = array();
            $_size85 = 0;
            $_etype88 = 0;
            $xfer += $input->readListBegin($_etype88, $_size85);
            for ($_i89 = 0; $_i89 < $_size85; ++$_i89)
            {
              $elem90 = null;
              $xfer += $input->readString($elem90);
              $this->successful []= $elem90;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->failed = array();
            $_size91 = 0;
            $_etype94 = 0;
            $xfer += $input->readListBegin($_etype94, $_size91);
            for ($_i95 = 0; $_i95 < $_size91; ++$_i95)
            {
              $elem96 = null;
              $elem96 = new \EMQ\Message\MessageBatchErrorEntry();
              $xfer += $elem96->read($input);
              $this->failed []= $elem96;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeleteMessageBatchResponse');
    if ($this->successful !== null) {
      if (!is_array($this->successful)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('successful', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->successful));
        {
          foreach ($this->successful as $iter97)
          {
            $xfer += $output->writeString($iter97);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->failed !== null) {
      if (!is_array($this->failed)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('failed', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->failed));
        {
          foreach ($this->failed as $iter98)
          {
            $xfer += $iter98->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


